---
title: ルーティング
description: Astroのルーティングの紹介
i18nReady: true
---
import FileTree from '~/components/FileTree.astro'
import RecipeLinks from "~/components/RecipeLinks.astro"
import Since from '~/components/Since.astro'

Astroは**ファイルベースルーティング**を使用して、プロジェクトの`src/pages/`ディレクトリのファイルレイアウトを元にビルドURLを生成します。

## ページ間の移動

Astro uses standard HTML [`<a>` elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a) to navigate between routes. There is no framework-specific `<Link>` component provided.

Astroでは、ルート間の移動に標準的なHTMLの[`<a>`要素](https://developer.mozilla.org/ja/docs/Web/HTML/Element/a)を使用します。フレームワーク固有の`<Link>`コンポーネントは提供されていません。

```astro title="src/pages/index.astro"
<p>Read more <a href="/about/">about</a> Astro!</p>
```

## 静的ルーティング

`src/pages/`ディレクトリにある`.astro`[ページコンポーネント](/ja/core-concepts/astro-pages/)、MarkdownとMDXファイル（`.md`、`.mdx`）は、**自動的にウェブサイトのページとなります**。各ページのルートは、`src/pages/`ディレクトリ内における自身のパスとファイル名に対応します。

```diff
# 例: 静的ルーティング
src/pages/index.astro        -> mysite.com/
src/pages/about.astro        -> mysite.com/about
src/pages/about/index.astro  -> mysite.com/about
src/pages/about/me.astro     -> mysite.com/about/me
src/pages/posts/1.md         -> mysite.com/posts/1
```

:::tip
Astroのプロジェクトでは、別途「ルーティング設定」を管理する必要はありません。`src/pages/` ディレクトリにファイルを配置すると、新しいルートが自動的に作成されます。静的ビルドでは、[`build.format`](/ja/reference/configuration-reference/#buildformat)設定オプションを使用して、ファイルの出力形式をカスタマイズできます。
:::


## 動的ルーティング

Astroページファイルのファイル名に動的ルートパラメータを指定すると、自身にマッチするページを複数生成できます。たとえば`src/pages/authors/[author].astro`は、ブログの各著者のプロフィールページを生成します。`author`は、ページ内からアクセス可能な*パラメーター*となります。

Astroデフォルトの静的出力モードでは、これらのページはビルド時に生成されるため、ページファイルに対応する`author`のリストを事前に決定する必要があります。SSRモードでは、ルートにマッチしたリクエストに応じてページが生成されます。

### 静的（SSG）モード

Because all routes must be determined at build time, a dynamic route must export a `getStaticPaths()` that returns an array of objects with a `params` property. Each of these objects will generate a corresponding route.

すべてのルートをビルド時に決定する必要があるため、動的ルートは`params`プロパティをもつオブジェクトの配列を返す`getStaticPaths()`をエクスポートする必要があります。各オブジェクトは対応するルートを生成します。

`[dog].astro` defines the dynamic `dog` parameter in its filename, so the objects returned by `getStaticPaths()` must include `dog` in their `params`. The page can then access this parameter using `Astro.params`.

`[dog].astro`はファイル名に動的な`dog`パラメーターが定義されているため、`getStaticPaths()`から返されるオブジェクトの`params`には`dog`を含める必要があります。`Astro.params`を使用してページからこのパラメーターにアクセスできます。

```astro title="src/pages/dogs/[dog].astro"
---
export function getStaticPaths() {
  return [
    {params: {dog: 'clifford'}},
    {params: {dog: 'rover'}},
    {params: {dog: 'spot'}},
  ];
}

const { dog } = Astro.params;
---
<div>いい子だ、{dog}！</div>
```

This will generate three pages: `/dogs/clifford`, `/dogs/rover`, and `/dogs/spot`, each displaying the corresponding dog name.

上のコードにより、`/dogs/clifford`、`/dogs/rover`、`/dogs/spot`という3つのページが生成され、各ページでは対応する犬の名前が表示されます。

The filename can include multiple parameters, which must all be included in the `params` objects in `getStaticPaths()`:

ファイル名には複数のパラメーターを含められますが、これらはすべて`getStaticPaths()`の`params`オブジェクトに含める必要があります。

```astro title="src/pages/[lang]-[version]/info.astro"
---
export function getStaticPaths () {
 return [
    {params: {lang: 'en', version: 'v1'}},
    {params: {lang: 'fr', version: 'v2'}},
  ];
}

const { lang, version } = Astro.params;
---
...
```

This will generate `/en-v1/info` and `/fr-v2/info`.

上のコードは`/en-v1/info`と`/fr-v2/info`を生成します。

Parameters can be included in separate parts of the path. For example, the file `src/pages/[lang]/[version]/info.astro` with the same `getStaticPaths()` above will generate the routes `/en/v1/info` and `/fr/v2/info`.

パラメーターはパス内の異なる部分に含められます。たとえば、上と同じ`getStaticPaths()`をもつ`src/pages/[lang]/[version]/info.astro`ファイルは、`/en/v1/info`と`/fr/v2/info`のルートを生成します。

📚 Learn more about [`getStaticPaths()`](/en/reference/api-reference/#getstaticpaths).

📚 [`getStaticPaths()`](/ja/reference/api-reference/#getstaticpaths)についてもっと学ぶ。

<RecipeLinks slugs={["ja/recipes/i18n"]} />

#### レストパラメーター

If you need more flexibility in your URL routing, you can use a [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters) (`[...path]`) in your `.astro` filename to match file paths of any depth:

URLルーティングをより柔軟におこないたい場合は、`.astro`ファイル名に[レストパラメーター](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Functions/rest_parameters)（`[...path]`）を使用することで、任意の深さのファイルパスにマッチさせられます。

```astro title="src/pages/sequences/[...path].astro"
---
export function getStaticPaths() {
  return [
    {params: {path: 'one/two/three'}},
    {params: {path: 'four'}},
    {params: {path: undefined }}
  ]
}

const { path } = Astro.params;
---
...
```

This will generate `/sequences/one/two/three`, `/sequences/four`, and `/sequences`. (Setting the rest parameter to `undefined` allows it to match the top level page.)

上のコードは`/sequences/one/two/three`、`/sequences/four`、`/sequences`を生成します。（レストパラメーターを`undefined`に設定することで、トップレベルのページにマッチさせられます。）

Rest parameters can be used with **other named parameters**. For example, GitHub's file viewer can be represented with the following dynamic route:

レストパラメーターは**他の名前付きパラメーター**と組み合わせて使用できます。たとえば、GitHubのファイルビューアは以下の動的ルートで表現できます。

```
/[org]/[repo]/tree/[branch]/[...file]
```
In this example, a request for `/withastro/astro/tree/main/docs/public/favicon.svg` would be split into the following named parameters:

この例では、`/withastro/astro/tree/main/docs/public/favicon.svg`へのリクエストは、以下の名前付きパラメーターへと分割されます。

```js
{
	org: 'withastro',
	repo: 'astro',
	branch: 'main',
	file: 'docs/public/favicon.svg'
}
```

#### 複数レベルの動的ページの例

In the following example, a rest parameter (`[...slug]`) and the [`props`](/en/reference/api-reference/#data-passing-with-props) feature of `getStaticPaths()` generate pages for slugs of different depths.

以下の例では、レストパラメーター（`[...slug]`）と`getStaticPaths()`の[`props`](/ja/reference/api-reference/#data-passing-with-props)機能を使用して、異なる深さのスラグのページを生成します。

```astro title="src/pages/[...slug].astro"
---
export async function getStaticPaths() {
  const pages = [
    {
      slug: undefined,
      title: "Astroストア",
      text: "Astroにようこそ！",
    },
    {
      slug: "products",
      title: "Astroグッズ",
      text: "たくさんの商品があります",
    },
    {
      slug: "products/astro-handbook",
      title: "究極のAstroハンドブック",
      text: "Astroについて学びたければ、この本を読む必要があります",
    },
  ];
  return pages.map(({ slug, title, text }) => {
    return {
      params: { slug },
      props: { title, text },
    };
  });
}

const { title, text } = Astro.props;
---
<html>
  <head>
    <title>{title}</title>
  </head>
  <body>
    <h1>{title}</h1>
    <p>{text}</p>
  </body>
</html>
```

### サーバー（SSR）モード
In [SSR mode](/en/guides/server-side-rendering/), dynamic routes are defined the same way: include `[param]` or `[...path]` brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not "static" routes, `getStaticPaths` should not be used.

[SSR](/ja/guides/server-side-rendering/)モードでも、動的ルートは同じように定義されます。つまり、任意の文字列やパスにマッチさせるために、ファイル名に`[param]`や`[...path]`などのブラケットを含められます。しかし、各ルートは事前にビルドされないため、ページはマッチしたすべてのルートに対して提供されます。これらは「静的」ルートではないため、`getStaticPaths`は使用できません。

```astro title="src/pages/resources/[resource]/[id].astro"
---
const { resource, id } = Astro.params;
---
<h1>{resource}: {id}</h1>
```
This page will be served for any value of `resource` and `id`: `resources/users/1`, `resources/colors/blue`, etc.

このページは、`resources/users/1`や`resources/colors/blue`など、任意の`resource`と`id`に対して提供されます。

#### `[...slug]`の例をSSR用に変更する

Because SSR pages can't use `getStaticPaths()`, they can't receive props. The [previous example](#example-dynamic-pages-at-multiple-levels) can be adapted for SSR mode by looking up the value of the `slug` param in an object. If the route is at the root ("/"), the slug param will be `undefined`. If the value doesn't exist in the object, we redirect to a 404 page.

SSRページでは`getStaticPaths()`を使用できないため、propsを受け取れません。しかし、オブジェクト内の`slug`パラメーターの値を参照することで、[前の例](#複数レベルの動的ページの例)をSSRモードにも対応させられます。"/"に対応するルートの場合、スラグパラメーターは`undefined`になります。値がオブジェクトに存在しない場合は、404ページにリダイレクトします。

```astro title="src/pages/[...slug].astro"
---
const pages = [
  {
    slug: undefined,
    title: "Astroストア",
    text: "Astroにようこそ！",
  },
  {
    slug: "products",
    title: "Astroグッズ",
    text: "たくさんの商品があります",
  },
  {
    slug: "products/astro-handbook",
    title: "究極のAstroハンドブック",
    text: "Astroについて学びたければ、この本を読む必要があります",
  },
];

const { slug } = Astro.params;
const page = pages.find((page) => page.slug === slug);
if (!page) return Astro.redirect("/404");
const { title, text } = page;
---
<html>
<head>
  <title>{title}</title>
</head>
<body>
  <h1>{title}</h1>
  <p>{text}</p>
</body>
</html>
```

## リダイレクト

Sometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route.

読者を新しいページにリダイレクトしなければいけない場合があります。サイトの構造が変更されたために永久的にリダイレクトする必要がある場合や、認証されたルートにログインするといったアクションに応じておこなう場合などです。

You can define rules to [redirect users to permanently-moved pages](#configured-redirects) in your Astro config. Or, [redirect users dynamically](#dynamic-redirects) as they use your site.

Astroの設定で、[永久的に移動したページにユーザーをリダイレクト](#リダイレクトの設定)するルールを定義できます。また、ユーザーがサイトを利用した際に[動的にリダイレクト](#動的リダイレクト)することもできます。

### リダイレクトの設定
<Since v="2.9.0" />

You can specify a mapping of permanent redirects in your Astro config with the `redirects` value. For most redirects, this is a mapping of an old route to the new route:

`redirects`値を使用して、Astroの設定から永久的なリダイレクトのマッピングを指定できます。ほとんどのリダイレクトでは、これは古いルートから新しいルートへのマッピングとなります。

```js title="astro.config.mjs" {4-6}
import { defineConfig } from 'astro/config';

export default defineConfig({
  redirects: {
    '/old-page': '/new-page'
  }
});
```

These redirects follow the same rules as file-based routes. Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example:

このリダイレクトは、ファイルベースルーティングと同じルールに従います。たとえば、新しいルートと古いルートの両方に同じパラメーターが含まれていれば、動的ルートも許可されます。

```js
{
  "/blog/[...slug]": "/articles/[...slug]"
}
```

Using SSR or a static adapter, you can also provide an object as the value, allowing you to specify the `status` code in addition to the new `destination`:

SSRまたは静的アダプターを使用するとオブジェクトを値として設定でき、そこで`status`コードや新しい`destination`を指定できます。

```js title="astro.config.mjs" {5-8}
import { defineConfig } from 'astro/config';

export default defineConfig({
  redirects: {
    '/old-page': {
      status: 302,
      destination: '/new-page'
    }
  }
});
```

When running `astro build`, Astro will output HTML files with the [meta refresh](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#examples) tag by default. Supported adapters will instead write out the host's configuration file with the redirects.

`astro build`の実行時に、Astroはデフォルトで[meta refresh](https://developer.mozilla.org/ja/docs/Web/HTML/Element/meta#examples)タグを含むHTMLファイルを出力します。サポートされているアダプターの場合は、代わりにホストの設定ファイルにリダイレクトを含めて出力します。

The status code is `301` by default. If building to HTML files the status code is not used by the server.

ステータスコードはデフォルトで`301`です。HTMLファイルをビルドする場合、ステータスコードはサーバーによって使用されません。

### 動的リダイレクト

On the `Astro` global, the `Astro.redirect` method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie.

`Astro`グローバルの`Astro.redirect`メソッドを使用すると、別のページに動的にリダイレクトできます。たとえばクッキーからセッションを取得してユーザーのログイン状態を確認した場合などにこれをおこないます。

```astro title="src/pages/account.astro" {8}
---
import { isLoggedIn } from '../utils';

const cookie = Astro.request.headers.get('cookie');

// ユーザーがログインしていない場合は、ログインページにリダイレクトする
if (!isLoggedIn(cookie)) {
  return Astro.redirect('/login');
}
---
<html>
  <!-- ページの内容... -->
</html>
```

## ルーティングの優先順位

複数のルートが同じURLのパスにマッチすることがあります。たとえば、以下の各ルートは`/posts/create`にマッチします。

<FileTree>
- src/pages/
  - posts/
    - create.astro
    - [pid].astro
    - [...slug].astro
</FileTree>

Astroは、ページをビルドするためにどのルートを使用すべきかを知る必要があります。そのために、以下のルールにしたがってルートの順番を決定します。

- パスパラメーターを持たない静的ルートは、他のすべてのルーティングよりも優先される
- 名前付きパラメーターを使用する動的ルーティングは、レストパラメーターよりも優先
- 事前レンダリングされる動的ルートは、サーバーの動的ルートよりも優先される
- レストパラメーターはもっとも低い優先度
- エンドポイントは常にページよりも優先される
- 同順位はアルファベット順に解決される

上記のようにファイルが配置されている場合に、リクエストされたURLと、HTMLをビルドするために使用されるルートがどのようにマッチングされるかの例をいくつか見てみましょう。

- `pages/posts/create.Astro` - `/posts/create`をビルドします
- `pages/posts/[pid].astro` - `/posts/1`, `/posts/abc`などをビルドします。しかし、`/posts/create`はビルドされません
- `pages/posts/[...slug].Astro` - `/posts/1/2`, `/posts/a/b/c`などをビルドします。しかし、 `/posts/create`、`/posts/1`、`/posts/abc`はビルドされません

Redirects also follow the same rules, but are prioritized *last*; if there is a file-based route and a redirect with the same route priority level, the file-based route is chosen.

リダイレクトも同じルールに従いますが、優先順位は*最後*になります。つまり、ファイルベースのルートとリダイレクトが同じルート優先順位である場合、ファイルベースのルートが選択されます。

## ページネーション

Astroは、複数のページに分割する必要がある大規模なデータコレクションのために、ページネーションを組み込みでサポートしています。Astroは、前ページと次ページのURL、総ページ数など、一般的なページネーションプロパティを生成します。

ページネーションされたルート名には、標準的な動的ルートと同じ`[ブラケット]`構文を使用する必要があります。たとえば、ファイル名 `/astronauts/[page].astro` は `/astronauts/1`, `/astronauts/2` などのルートを生成し、`[page]`は生成されるページ番号となります。

`paginate()`関数を使用すると、次のように値の配列に対してこれらのページを生成できます。

```astro /{ (paginate) }/ /paginate\\(.*\\)/ /(?<=const.*)(page)/ /page\\.[a-zA-Z]+/
---
// 例: /src/pages/astronauts/[page].astro
export async function getStaticPaths({ paginate }) {
  const astronautPages = [{
    astronaut: 'ニール・アームストロング',
  }, {
    astronaut: 'バズ・オルドリン',
  }, {
    astronaut: 'サリー・ライド',
  }, {
    astronaut: 'ジョン・グレン',
  }];
  // 宇宙飛行士の配列から、1ページに2人づつ入るようにページを生成します
  return paginate(astronautPages, { pageSize: 2 });
}
// ページネーションされたデータは、すべて"page"プロパティとして渡されます
const { page } = Astro.props;
---

<!--現在のページ番号を表示します。Astro.params.pageも使用可能です！-->
<h1>{page.currentPage}ページ</h1>
<ul>
  <!--宇宙飛行士情報の配列を列挙します-->
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
```

これで、1ページに2つのアイテムが配置された、以下のページが生成されます。
- `/astronauts/1` - 1ページ目には「ニール・アームストロング」と「バズ・オルドリン」を表示します
- `/astronauts/2` - 2ページ目には「サリー・ライド」と「ジョン・グレン」を表示します


### `page` プロパティ

`paginate()`関数を使用すると、各ページのデータは`page`プロパティで渡されます。`page`プロパティは多くの便利なプロパティを持っていますが、ここではそのうち重要なものを紹介します。
- **page.data** - `paginate()`関数に渡された、ページのスライスデータを含む配列です
- **page.url.next** - セット内の次のページへのリンクです
- **page.url.prev** - セット内の前のページへのリンクです

```astro /(?<=const.*)(page)/ /page\\.[a-zA-Z]+(?:\\.(?:prev|next))?/
---
// 例: /src/pages/astronauts/[page].astro
// 前の例と同じように、{ astronaut } オブジェクトのリストをページネーションします
export async function getStaticPaths({ paginate }) { /* ... */ }
const { page } = Astro.props;
---
<h1>{page.currentPage}ページ</h1>
<ul>
  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}
</ul>
{page.url.prev ? <a href={page.url.prev}>Previous</a> : null}
{page.url.next ? <a href={page.url.next}>Next</a> : null}
```


#### 完全なAPIリファレンス

```ts
interface Page<T = any> {
	/** 結果 */
	data: T[];
	/** メタデータ */
	/** 0から始まる、ページ上の最初のアイテムのインデックス */
	start: number;
	/** ページ上の最後のアイテムのインデックス */
	end: number;
	/** 結果の総数 */
	total: number;
	/** 1から始まる、現在のページ番号 */
	currentPage: number;
	/** 1ページあたりのアイテム数（デフォルトは25） */
	size: number;
	/** 最終ページ番号 */
	lastPage: number;
	url: {
		/** 現在のページのURL */
		current: string;
		/** 前のページのURL（もしあれば） */
		prev: string | undefined;
		/** 次のページのURL（もしあれば） */
		next: string | undefined;
	};
}
```

### ネストされたページネーション

ページ分割のより高度なユースケースは**ネストされたページ分割**です。これは、ページ分割を他の動的ルーティングパラメーターと組み合わせた場合です。ネストされたページ分割を使用すると、ページ分割されたコレクションを何らかのプロパティやタグでグループ化できます。

たとえば、ページ分割されたMarkdownの投稿を何らかのタグでグループ化したい場合、以下のURLにマッチする `/src/pages/[tag]/[page].Astro` ページを作成することでネストされたページングを使用することになります。

- `/red/1` (tag=red)
- `/red/2` (tag=red)
- `/blue/1` (tag=blue)
- `/green/1` (tag=green)

ネストされたページ分割は、 `getStaticPaths()` から `paginate()` の結果を、グループ化ごとに配列として返すことで動作します。

この例では、上記のURLを作成するために、ネストされたページ送りを実装します。

```astro
---
// 例: /src/pages/[tag]/[page].astro
export function getStaticPaths({paginate}) {
  const allTags = ['red', 'blue', 'green'];
  const allPosts = await Astro.glob('../../posts/*.md');
  // すべてのタグに対して、paginate() の結果を返す。
  // 必ず、`{params: {tag}} を `paginate()` に渡してください。
  // そうすれば、Astroは結果がどのタググループに対するものか分かります。
  return allTags.map((tag) => {
    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);
    return paginate(filteredPosts, {
      params: { tag },
      pageSize: 10
    });
  });
}
const { page } = Astro.props;
const params = Astro.params;
```

## ページの除外

You can exclude pages or directories from being built by prefixing their names with an underscore (`_`). Files with the `_` prefix won't be recognized by the router and won't be placed into the `dist/` directory.

You can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages. 

In this example, only `src/pages/index.astro` and `src/pages/posts/post1.md` will be built as page routes and HTML files.

<FileTree>
- src/pages/
  - _hidden-directory/
    - page1.md
    - page2.md
  - _hidden-page.astro
  - **index.astro**
  - posts/
    - _SomeComponent.astro
    - _utils.js
    - **post1.md**
</FileTree>
